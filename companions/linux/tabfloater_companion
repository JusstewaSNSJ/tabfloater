#!/bin/bash

function get_json_input_strip_whitespace() {
    # As described in the Chrome native messaging protocol, the JSON is preceded
    # with the message length in the first 4 bytes. We need to strip that, so we
    # ignore the input characters until we reach the start of the JSON
    # (the '{' character). We terminate reading from the input when we reach the
    # closing character of the JSON ('}'). This wouldn't work for nested JSONs, but
    # TabFloater only sends non-nested JSON, so this works fine.

    local _input="{"

    while IFS= read -r -n1 c; do
        if [ "$c" == '{' ]; then
            break
        fi
    done
    while IFS= read -r -n1 c; do
        _input="$_input$c"
        if [ "$c" == '}' ]; then
            break
        fi
    done

    echo $_input | tr -d [:space:]
}

function get_first_capture_group() {
    local _str=$1
    local _regex=$2

    if [[ $_str =~ $_regex ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        echo ""
    fi
}

function get_json_single_value () {
    local _json=$1
    local _json_key=$2
    local _regex="\"$_json_key\":\"([^\"]*)\",?"

    echo $(get_first_capture_group $_json $_regex)
}

function send_message {
    local _message=$1
    # Calculate the byte size of the string. This only works if the byte length
    # is identical to the string length - it would not work, if we sent multibyte
    # characters. TabFloater only sends ASCII characters, so this works fine. We
    # then convert the length to an integer in native byte order - this only works
    # for little endian systems, but the majority of modern desktops use that.
    local _messagelen=${#_message}
    local _messagelen1=$(( ($_messagelen      ) & 0xFF ))
    local _messagelen2=$(( ($_messagelen >>  8) & 0xFF ))
    local _messagelen3=$(( ($_messagelen >> 16) & 0xFF ))
    local _messagelen4=$(( ($_messagelen >> 24) & 0xFF ))

    # Print the message byte length followed by the actual message.
    printf "$(printf '\\x%x\\x%x\\x%x\\x%x' $_messagelen1 $_messagelen2 $_messagelen3 $_messagelen4)%s" "$_message"
}

function send_status {
    local _json="{\"status\":\"$1\"}"
    send_message $_json
}

function send_result {
    local _json="{\"result\":\"$1\"}"
    send_message $_json
}

function test_tools_availability {
    # if ! wmctrl --help > /dev/null ; then
    #     return 1
    # fi

    return 0
}

_input_json=$(get_json_input_strip_whitespace)
_action=$(get_json_single_value $_input_json "action")
_title=$(get_json_single_value $_input_json "title")

if [ "$_action" == "ping" ]; then
    if test_tools_availability; then
        send_status "ok"
    else
        send_status "inactive"
    fi
elif [ "$_action" == "makepanel" ]; then
    send_result "ok"
else
    echo "something else"
fi
